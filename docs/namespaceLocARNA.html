<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LocARNA-2.0.0: LocARNA Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LocARNA-2.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LocARNA Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1greater__second.html">greater_second</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements comparison by member second.  <a href="classLocARNA_1_1greater__second.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Aligner.html">Aligner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements locarna alignment algorithm.  <a href="classLocARNA_1_1Aligner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple 2D matrix class, provides access via operator (int,int)  <a href="classLocARNA_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerImpl.html">AlignerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Aligner.  <a href="classLocARNA_1_1AlignerImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerN.html">AlignerN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements SPARSE, next generation alignment algorithm for locarna.  <a href="classLocARNA_1_1AlignerN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerP.html">AlignerP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes partition function of alignment, arc match and base match probabilities.  <a href="classLocARNA_1_1AlignerP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1tuple__cat__type.html">tuple_cat_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of two concattenated tuples  <a href="structLocARNA_1_1tuple__cat__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1tuple__cat__type_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">tuple_cat_type&lt; std::tuple&lt; Ts... &gt;, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerParams.html">AlignerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for alignment by Aligner.  <a href="classLocARNA_1_1AlignerParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerPParams.html">AlignerPParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for AlignerP  <a href="classLocARNA_1_1AlignerPParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerNParams.html">AlignerNParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for AlignerN  <a href="classLocARNA_1_1AlignerNParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignerRestriction.html">AlignerRestriction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts range of an alignment in Aligner.  <a href="classLocARNA_1_1AlignerRestriction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1EdgeEnd.html">EdgeEnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">end of an alignment edge  <a href="classLocARNA_1_1EdgeEnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignmentEdges.html">AlignmentEdges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Alignment.html">Alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a structure-annotated sequence alignment.  <a href="classLocARNA_1_1Alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AlignmentImpl.html">AlignmentImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Alignment.  <a href="classLocARNA_1_1AlignmentImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Alphabet.html">Alphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an alphabet of static size.  <a href="classLocARNA_1_1Alphabet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1AnchorConstraints.html">AnchorConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents anchor constraints between two sequences.  <a href="classLocARNA_1_1AnchorConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ArcMatch.html">ArcMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a match of two base pairs (arc match)  <a href="classLocARNA_1_1ArcMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ArcMatches.html">ArcMatches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains the relevant arc matches and their scores.  <a href="classLocARNA_1_1ArcMatches.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ArcMatchesIndexed.html">ArcMatchesIndexed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class ArcMatches with additional mapping  <a href="classLocARNA_1_1ArcMatchesIndexed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1check__score__t.html">check_score_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1check__score__t_3_01extended__pf__score__t_01_4.html">check_score_t&lt; extended_pf_score_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1failure.html">failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple exception class that supports a text message.  <a href="classLocARNA_1_1failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1wrong__format__failure.html">wrong_format_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">thrown, when reading data that is not in the supposed format  <a href="structLocARNA_1_1wrong__format__failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1syntax__error__failure.html">syntax_error_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">thrown, when the format is recognized but syntax is incorrect  <a href="structLocARNA_1_1syntax__error__failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Delay.html">Delay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1make__delay.html">make_delay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1BasePairs____Arc.html">BasePairs__Arc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a base pair.  <a href="classLocARNA_1_1BasePairs____Arc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1BasePairs.html">BasePairs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes sequence and structure ensemble of an RNA.  <a href="classLocARNA_1_1BasePairs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ConfusionMatrix.html">ConfusionMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare RNA secondary structure by their confusion matrix.  <a href="classLocARNA_1_1ConfusionMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1DiscreteDistribution.html">DiscreteDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1EdgeProbs.html">EdgeProbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides probabilities for alignment egdes (match or trace probabilities etc).  <a href="classLocARNA_1_1EdgeProbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1MatchProbs.html">MatchProbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide match probabilities.  <a href="classLocARNA_1_1MatchProbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PFGotoh.html">PFGotoh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide Gotoh partition functions.  <a href="classLocARNA_1_1PFGotoh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1TraceProbs.html">TraceProbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide trace probabilities.  <a href="classLocARNA_1_1TraceProbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PFMatchProbs.html">PFMatchProbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide match probabilities calculated by pf approach.  <a href="classLocARNA_1_1PFMatchProbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PFTraceProbs.html">PFTraceProbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide match probabilities calculated by pf approach.  <a href="classLocARNA_1_1PFTraceProbs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PairHMMMatchProbs.html">PairHMMMatchProbs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SinglePattern.html">SinglePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores a Pattern in one sequence  <a href="classLocARNA_1_1SinglePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PatternPair.html">PatternPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">is able to manage an EPM, consists of 2 singlepatterns, one in each RNA  <a href="classLocARNA_1_1PatternPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PatternPairMap.html">PatternPairMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">manage a set of EPMs (PatternPair)  <a href="classLocARNA_1_1PatternPairMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1LCSEPM.html">LCSEPM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the best chain of EPMs, the LCS-EPM  <a href="classLocARNA_1_1LCSEPM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SparseTraceController.html">SparseTraceController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines the TraceController with the Mapper for both sequences  <a href="classLocARNA_1_1SparseTraceController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1EPM.html">EPM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class for the representation of exact pattern matches (EPM)  <a href="classLocARNA_1_1EPM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ExactMatcher.html">ExactMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes exact pattern matchings (EPM) between two RNA sequences.  <a href="classLocARNA_1_1ExactMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ExtRnaData.html">ExtRnaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent sparsified data of RNA ensemble extended by in loop probabilities  <a href="classLocARNA_1_1ExtRnaData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ExtRnaDataImpl.html">ExtRnaDataImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ExtRnaData.  <a href="classLocARNA_1_1ExtRnaDataImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1FitOnOff.html">FitOnOff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements fitting of a two-step function to a number sequence.  <a href="classLocARNA_1_1FitOnOff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1FitOnOffVarPenalty.html">FitOnOffVarPenalty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fitting of a two-step function with position-specific step penalities.  <a href="classLocARNA_1_1FitOnOffVarPenalty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1FreeEndgaps.html">FreeEndgaps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of free end gaps.  <a href="classLocARNA_1_1FreeEndgaps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RMatrix.html">RMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple matrix class with restriction to a range.  <a href="classLocARNA_1_1RMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1OMatrix.html">OMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple matrix class with offset.  <a href="classLocARNA_1_1OMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RotMatrix.html">RotMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix class with rotation.  <a href="classLocARNA_1_1RotMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1McC__matrices__base.html">McC_matrices_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1McC__matrices__t.html">McC_matrices_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">McCaskill matrices.  <a href="classLocARNA_1_1McC__matrices__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1McC__ali__matrices__t.html">McC_ali_matrices_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alifold-McCaskill matrices.  <a href="classLocARNA_1_1McC__ali__matrices__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1MultipleAlignment.html">MultipleAlignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a multiple alignment.  <a href="classLocARNA_1_1MultipleAlignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1has__type.html">has_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1has__type_3_01T_00_01std_1_1tuple_3_4_01_4.html">has_type&lt; T, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1has__type_3_01T_00_01std_1_1tuple_3_01U_00_01Ts_8_8_8_01_4_01_4.html">has_type&lt; T, std::tuple&lt; U, Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1has__type_3_01T_00_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html">has_type&lt; T, std::tuple&lt; T, Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1contains.html">contains</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1contains_3_01T_00_01std_1_1tuple_3_4_01_4.html">contains&lt; T, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1contains_3_01T_00_01std_1_1tuple_3_01U_00_01Us_8_8_8_01_4_01_4.html">contains&lt; T, std::tuple&lt; U, Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1contains_3_01T_00_01std_1_1tuple_3_01T_00_01Us_8_8_8_01_4_01_4.html">contains&lt; T, std::tuple&lt; T, Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1type__subset__of.html">type_subset_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1type__subset__of_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01std_1_1tuple_3_4_01_4.html">type_subset_of&lt; std::tuple&lt; Ts... &gt;, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1type__subset__of_3_01std_1_1tuple_3_4_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">type_subset_of&lt; std::tuple&lt;&gt;, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1type__subset__of_3_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">type_subset_of&lt; std::tuple&lt; T, Ts... &gt;, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1NamedArgument.html">NamedArgument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition structure of an option.  <a href="structLocARNA_1_1option__def.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PFoldParams.html">PFoldParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for partition folding.  <a href="classLocARNA_1_1PFoldParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Ribofit.html">Ribofit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Family of Ribofit matrices.  <a href="classLocARNA_1_1Ribofit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Ribofit__will2014.html">Ribofit_will2014</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Ribosum.html">Ribosum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents ribosum similarity matrices.  <a href="classLocARNA_1_1Ribosum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RibosumFreq.html">RibosumFreq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents ribosum similarity matrices including raw frequencies.  <a href="classLocARNA_1_1RibosumFreq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RnaData.html">RnaData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represent sparsified data of RNA ensemble  <a href="classLocARNA_1_1RnaData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RnaDataImpl.html">RnaDataImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of RnaData.  <a href="classLocARNA_1_1RnaDataImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RnaEnsemble.html">RnaEnsemble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the raw structure ensemble data for an RNA.  <a href="classLocARNA_1_1RnaEnsemble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RnaEnsembleImpl.html">RnaEnsembleImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of RnaEnsemble.  <a href="classLocARNA_1_1RnaEnsembleImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1RnaStructure.html">RnaStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RNA secondary structure.  <a href="classLocARNA_1_1RnaStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ScoringParams.html">ScoringParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for scoring.  <a href="classLocARNA_1_1ScoringParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Scoring.html">Scoring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides methods for the scoring of alignments.  <a href="classLocARNA_1_1Scoring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1PFScoring.html">PFScoring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Sequence.html">Sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Sequence View" of multiple alignment as array of column vectors  <a href="classLocARNA_1_1Sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SequenceAnnotation.html">SequenceAnnotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation of a sequence.  <a href="classLocARNA_1_1SequenceAnnotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SparseMatrix.html">SparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sparse 2D matrix.  <a href="classLocARNA_1_1SparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SparseVector.html">SparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sparse vector.  <a href="classLocARNA_1_1SparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SparseVectorBase.html">SparseVectorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for sparse vector and matrix.  <a href="classLocARNA_1_1SparseVectorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1SparsificationMapper.html">SparsificationMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the mapping for sparsification.  <a href="classLocARNA_1_1SparsificationMapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1StopWatch.html">StopWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">control a set of named stop watch like timers  <a href="classLocARNA_1_1StopWatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1StralScore.html">StralScore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the stral-like scoring function.  <a href="classLocARNA_1_1StralScore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1string1.html">string1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple 1-based string.  <a href="classLocARNA_1_1string1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1TraceRange.html">TraceRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a range of traces.  <a href="classLocARNA_1_1TraceRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1MatchController.html">MatchController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract class that declares the method is_valid_match()  <a href="classLocARNA_1_1MatchController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1TraceController.html">TraceController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the matrix cells valid for traces.  <a href="classLocARNA_1_1TraceController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1triple.html">triple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3-tuple.  <a href="classLocARNA_1_1triple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1quadruple.html">quadruple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 4-tuple.  <a href="classLocARNA_1_1quadruple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1quintuple.html">quintuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 5-tuple.  <a href="classLocARNA_1_1quintuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Zip.html">Zip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1ConstIterableSequence.html">ConstIterableSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLocARNA_1_1Enumerate.html">Enumerate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04a647069939d56e99c0806d6c64e5a0"><td class="memItemLeft" align="right" valign="top"><a id="a04a647069939d56e99c0806d6c64e5a0"></a>
typedef std::pair&lt; <a class="el" href="classLocARNA_1_1AlignerRestriction.html">AlignerRestriction</a>, <a class="el" href="namespaceLocARNA.html#ae111d1cda0f077827bd2e90d6b14cff3">infty_score_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a04a647069939d56e99c0806d6c64e5a0">task_t</a></td></tr>
<tr class="memdesc:a04a647069939d56e99c0806d6c64e5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a task (used in computing k-best alignment) <br /></td></tr>
<tr class="separator:a04a647069939d56e99c0806d6c64e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77faf6648dd8631aac85fadfc1deffae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a77faf6648dd8631aac85fadfc1deffae">ProbMatrix</a></td></tr>
<tr class="memdesc:a77faf6648dd8631aac85fadfc1deffae"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix for storing probabilities  <a href="namespaceLocARNA.html#a77faf6648dd8631aac85fadfc1deffae">More...</a><br /></td></tr>
<tr class="separator:a77faf6648dd8631aac85fadfc1deffae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502d22e53b42b2619ae06082272ad166"><td class="memItemLeft" align="right" valign="top"><a id="a502d22e53b42b2619ae06082272ad166"></a>
typedef <a class="el" href="classLocARNA_1_1SparseMatrix.html">SparseMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a502d22e53b42b2619ae06082272ad166">SparseProbMatrix</a></td></tr>
<tr class="memdesc:a502d22e53b42b2619ae06082272ad166"><td class="mdescLeft">&#160;</td><td class="mdescRight">sparse matrix for storing probabilities <br /></td></tr>
<tr class="separator:a502d22e53b42b2619ae06082272ad166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a82446fefd03ec7ecb454eb8890f5de"><td class="memItemLeft" align="right" valign="top"><a id="a4a82446fefd03ec7ecb454eb8890f5de"></a>
typedef <a class="el" href="classLocARNA_1_1AlignerRestriction.html">AlignerRestriction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a4a82446fefd03ec7ecb454eb8890f5de">AlignerPRestriction</a></td></tr>
<tr class="memdesc:a4a82446fefd03ec7ecb454eb8890f5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">restriction of AlignerP ( same as for Aligner ) <br /></td></tr>
<tr class="separator:a4a82446fefd03ec7ecb454eb8890f5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c94a0f84d23e7a6d7ef7f1cb9f2e3f"><td class="memTemplParams" colspan="2"><a id="a96c94a0f84d23e7a6d7ef7f1cb9f2e3f"></a>
template&lt;typename Tuple1 , typename Tuple2 &gt; </td></tr>
<tr class="memitem:a96c94a0f84d23e7a6d7ef7f1cb9f2e3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_cat_type_t</b> = typename <a class="el" href="structLocARNA_1_1tuple__cat__type.html">tuple_cat_type</a>&lt; Tuple1, Tuple2 &gt;::type</td></tr>
<tr class="separator:a96c94a0f84d23e7a6d7ef7f1cb9f2e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1922d5f835e554ba4caf8bef864f00"><td class="memItemLeft" align="right" valign="top"><a id="a7a1922d5f835e554ba4caf8bef864f00"></a>
typedef std::vector&lt; <a class="el" href="classLocARNA_1_1ArcMatch.html">ArcMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a7a1922d5f835e554ba4caf8bef864f00">ArcMatchVec</a></td></tr>
<tr class="memdesc:a7a1922d5f835e554ba4caf8bef864f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of arc matches. <br /></td></tr>
<tr class="separator:a7a1922d5f835e554ba4caf8bef864f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56133dbdfa188d5d5fc9c54b4fb6d160"><td class="memItemLeft" align="right" valign="top"><a id="a56133dbdfa188d5d5fc9c54b4fb6d160"></a>
typedef std::vector&lt; <a class="el" href="classLocARNA_1_1ArcMatch.html#abe50ab349a68390fb2b0d79119e598f6">ArcMatch::idx_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a56133dbdfa188d5d5fc9c54b4fb6d160">ArcMatchIdxVec</a></td></tr>
<tr class="memdesc:a56133dbdfa188d5d5fc9c54b4fb6d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of arc match indices. <br /></td></tr>
<tr class="separator:a56133dbdfa188d5d5fc9c54b4fb6d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dcaefac7cd276b0253ca4cfb095990"><td class="memItemLeft" align="right" valign="top"><a id="a07dcaefac7cd276b0253ca4cfb095990"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>standard_pf_score_t</b> = double</td></tr>
<tr class="separator:a07dcaefac7cd276b0253ca4cfb095990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd525730fe5f2200493cf2545ce52a4f"><td class="memItemLeft" align="right" valign="top"><a id="abd525730fe5f2200493cf2545ce52a4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>extended_pf_score_t</b> = long double</td></tr>
<tr class="separator:abd525730fe5f2200493cf2545ce52a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e31eebdbf1c9198de5e931ae78e86"><td class="memItemLeft" align="right" valign="top"><a id="a133e31eebdbf1c9198de5e931ae78e86"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>quad_pf_score_t</b> = long double</td></tr>
<tr class="separator:a133e31eebdbf1c9198de5e931ae78e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6caff014e7d9621f0aa488846afe0b"><td class="memItemLeft" align="right" valign="top"><a id="adc6caff014e7d9621f0aa488846afe0b"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#adc6caff014e7d9621f0aa488846afe0b">size_type</a></td></tr>
<tr class="memdesc:adc6caff014e7d9621f0aa488846afe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">general size type <br /></td></tr>
<tr class="separator:adc6caff014e7d9621f0aa488846afe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1758b660452fd970d2e62d5749d87"><td class="memItemLeft" align="right" valign="top"><a id="a17e1758b660452fd970d2e62d5749d87"></a>
typedef <a class="el" href="namespaceLocARNA.html#adc6caff014e7d9621f0aa488846afe0b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a17e1758b660452fd970d2e62d5749d87">pos_type</a></td></tr>
<tr class="memdesc:a17e1758b660452fd970d2e62d5749d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a sequence position <br /></td></tr>
<tr class="separator:a17e1758b660452fd970d2e62d5749d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19a1f8c8ca6a6070c38a898d2b8db4"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aec19a1f8c8ca6a6070c38a898d2b8db4">FLT_OR_DBL</a></td></tr>
<tr class="memdesc:aec19a1f8c8ca6a6070c38a898d2b8db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">select FLT_OR_DBL  <a href="namespaceLocARNA.html#aec19a1f8c8ca6a6070c38a898d2b8db4">More...</a><br /></td></tr>
<tr class="separator:aec19a1f8c8ca6a6070c38a898d2b8db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d55bb3feb3f687899e6bd1defc1ef7"><td class="memItemLeft" align="right" valign="top"><a id="aa5d55bb3feb3f687899e6bd1defc1ef7"></a>
typedef std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>intVec</b></td></tr>
<tr class="separator:aa5d55bb3feb3f687899e6bd1defc1ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14c22326908cf634a3653c4002de907"><td class="memItemLeft" align="right" valign="top"><a id="aa14c22326908cf634a3653c4002de907"></a>
typedef std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>intPair</b></td></tr>
<tr class="separator:aa14c22326908cf634a3653c4002de907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932894f339c0d202996c367e214673b6"><td class="memItemLeft" align="right" valign="top"><a id="a932894f339c0d202996c367e214673b6"></a>
typedef std::pair&lt; intPair, intPair &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>intPPair</b></td></tr>
<tr class="separator:a932894f339c0d202996c367e214673b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70af54ab71ed37495122d4441579e95"><td class="memItemLeft" align="right" valign="top"><a id="ad70af54ab71ed37495122d4441579e95"></a>
typedef const intPPair *&#160;</td><td class="memItemRight" valign="bottom"><b>intPPairPTR</b></td></tr>
<tr class="separator:ad70af54ab71ed37495122d4441579e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4c9068820381e75a41388ae460d90"><td class="memItemLeft" align="right" valign="top"><a id="a83a4c9068820381e75a41388ae460d90"></a>
typedef std::vector&lt; intPPair &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>IntPPairCITER</b></td></tr>
<tr class="separator:a83a4c9068820381e75a41388ae460d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c5d9a3978c0d4f04b57865e7579f21"><td class="memItemLeft" align="right" valign="top"><a id="a07c5d9a3978c0d4f04b57865e7579f21"></a>
typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>numseq_t</b></td></tr>
<tr class="separator:a07c5d9a3978c0d4f04b57865e7579f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac428f54a2f23f26f1262e3fbfd4de022"><td class="memItemLeft" align="right" valign="top"><a id="ac428f54a2f23f26f1262e3fbfd4de022"></a>
typedef long double&#160;</td><td class="memItemRight" valign="bottom"><b>pf_t</b></td></tr>
<tr class="separator:ac428f54a2f23f26f1262e3fbfd4de022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e27e4384babbbaeafe3358195012f"><td class="memTemplParams" colspan="2"><a id="af05e27e4384babbbaeafe3358195012f"></a>
template&lt;typename T , typename... Us&gt; </td></tr>
<tr class="memitem:af05e27e4384babbbaeafe3358195012f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains_t</b> = typename <a class="el" href="structLocARNA_1_1contains.html">contains</a>&lt; T, Us... &gt;::type</td></tr>
<tr class="separator:af05e27e4384babbbaeafe3358195012f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3034c47ae0580ba18b908199b7eb94f2"><td class="memItemLeft" align="right" valign="top"><a id="a3034c47ae0580ba18b908199b7eb94f2"></a>
typedef std::vector&lt; <a class="el" href="namespaceLocARNA.html#ae111d1cda0f077827bd2e90d6b14cff3">infty_score_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a3034c47ae0580ba18b908199b7eb94f2">ScoreVector</a></td></tr>
<tr class="memdesc:a3034c47ae0580ba18b908199b7eb94f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of scores supporting infinity <br /></td></tr>
<tr class="separator:a3034c47ae0580ba18b908199b7eb94f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2fbd82542fdaf224e9dec48faca81f"><td class="memItemLeft" align="right" valign="top"><a id="aac2fbd82542fdaf224e9dec48faca81f"></a>
typedef <a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; <a class="el" href="namespaceLocARNA.html#ae111d1cda0f077827bd2e90d6b14cff3">infty_score_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aac2fbd82542fdaf224e9dec48faca81f">ScoreMatrix</a></td></tr>
<tr class="memdesc:aac2fbd82542fdaf224e9dec48faca81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of scores supporting infinity <br /></td></tr>
<tr class="separator:aac2fbd82542fdaf224e9dec48faca81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0c4dfec0e83ac075b2e9a1e3746ea"><td class="memItemLeft" align="right" valign="top"><a id="ae4e0c4dfec0e83ac075b2e9a1e3746ea"></a>
typedef long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ae4e0c4dfec0e83ac075b2e9a1e3746ea">score_t</a></td></tr>
<tr class="memdesc:ae4e0c4dfec0e83ac075b2e9a1e3746ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the locarna score as defined by the class Scoring <br /></td></tr>
<tr class="separator:ae4e0c4dfec0e83ac075b2e9a1e3746ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae111d1cda0f077827bd2e90d6b14cff3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ae111d1cda0f077827bd2e90d6b14cff3">infty_score_t</a></td></tr>
<tr class="separator:ae111d1cda0f077827bd2e90d6b14cff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7d7a8a31fe75c2b6ae247648edc24"><td class="memItemLeft" align="right" valign="top"><a id="a4cd7d7a8a31fe75c2b6ae247648edc24"></a>
typedef <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tainted_infty_score_t</b></td></tr>
<tr class="separator:a4cd7d7a8a31fe75c2b6ae247648edc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a758ae1532980fcf337a525fe95966f40"><td class="memItemLeft" align="right" valign="top"><a id="a758ae1532980fcf337a525fe95966f40"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a758ae1532980fcf337a525fe95966f40">Gap</a> { <b>regular</b>
, <b>loop</b>
, <b>locality</b>
, <b>other</b>
 }</td></tr>
<tr class="memdesc:a758ae1532980fcf337a525fe95966f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">different types of gaps <br /></td></tr>
<tr class="separator:a758ae1532980fcf337a525fe95966f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a213e1cc9393b5afb4e847ffea0a62de0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a213e1cc9393b5afb4e847ffea0a62de0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1AlignerRestriction.html">AlignerRestriction</a> &amp;r)</td></tr>
<tr class="separator:a213e1cc9393b5afb4e847ffea0a62de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8137ad7797225a5fc078e9264ce3db"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:aed8137ad7797225a5fc078e9264ce3db"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aed8137ad7797225a5fc078e9264ce3db">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1Alphabet.html">Alphabet</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:aed8137ad7797225a5fc078e9264ce3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa694cc6938cf6d2df2b3b1bd04a5026a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aa694cc6938cf6d2df2b3b1bd04a5026a">is_gap_symbol</a> (char c)</td></tr>
<tr class="memdesc:aa694cc6938cf6d2df2b3b1bd04a5026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for gap symbol.  <a href="namespaceLocARNA.html#aa694cc6938cf6d2df2b3b1bd04a5026a">More...</a><br /></td></tr>
<tr class="separator:aa694cc6938cf6d2df2b3b1bd04a5026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b0a67a5754bf472c61c737234e7aed"><td class="memItemLeft" align="right" valign="top"><a id="a15b0a67a5754bf472c61c737234e7aed"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a15b0a67a5754bf472c61c737234e7aed">gap_symbol</a> (<a class="el" href="namespaceLocARNA.html#a758ae1532980fcf337a525fe95966f40">Gap</a> gap)</td></tr>
<tr class="memdesc:a15b0a67a5754bf472c61c737234e7aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified symbols of gaps <br /></td></tr>
<tr class="separator:a15b0a67a5754bf472c61c737234e7aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2240c9815582221aea3d0e7847ba57b6"><td class="memItemLeft" align="right" valign="top"><a id="a2240c9815582221aea3d0e7847ba57b6"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a2240c9815582221aea3d0e7847ba57b6">special_gap_symbol</a> (<a class="el" href="namespaceLocARNA.html#a758ae1532980fcf337a525fe95966f40">Gap</a> gap)</td></tr>
<tr class="memdesc:a2240c9815582221aea3d0e7847ba57b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">special symbols of gaps <br /></td></tr>
<tr class="separator:a2240c9815582221aea3d0e7847ba57b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc37f42a274171d8e85ac488e890e8d"><td class="memItemLeft" align="right" valign="top"><a id="a8dc37f42a274171d8e85ac488e890e8d"></a>
<a class="el" href="namespaceLocARNA.html#a758ae1532980fcf337a525fe95966f40">Gap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a8dc37f42a274171d8e85ac488e890e8d">gap_code</a> (char symbol)</td></tr>
<tr class="memdesc:a8dc37f42a274171d8e85ac488e890e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">code of a gap symbol <br /></td></tr>
<tr class="separator:a8dc37f42a274171d8e85ac488e890e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac064250cb39851185b7fb25eebf1d756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ac064250cb39851185b7fb25eebf1d756">transform_toupper</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:ac064250cb39851185b7fb25eebf1d756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts char to upper case.  <a href="namespaceLocARNA.html#ac064250cb39851185b7fb25eebf1d756">More...</a><br /></td></tr>
<tr class="separator:ac064250cb39851185b7fb25eebf1d756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec4b9da4789fd38379743edb18be34e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a1ec4b9da4789fd38379743edb18be34e">normalize_rna_sequence</a> (std::string &amp;seq)</td></tr>
<tr class="memdesc:a1ec4b9da4789fd38379743edb18be34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an RNA sequence string.  <a href="namespaceLocARNA.html#a1ec4b9da4789fd38379743edb18be34e">More...</a><br /></td></tr>
<tr class="separator:a1ec4b9da4789fd38379743edb18be34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd81b1324e262d2f5a9609036af4889"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a0fd81b1324e262d2f5a9609036af4889">has_prefix</a> (const std::string &amp;s, const std::string &amp;p, size_t start=0)</td></tr>
<tr class="memdesc:a0fd81b1324e262d2f5a9609036af4889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test string prefix.  <a href="namespaceLocARNA.html#a0fd81b1324e262d2f5a9609036af4889">More...</a><br /></td></tr>
<tr class="separator:a0fd81b1324e262d2f5a9609036af4889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f4d23581cc9919bf2479f31a37fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a267f4d23581cc9919bf2479f31a37fd8">split_at_separator</a> (const std::string &amp;s, char sep, std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a267f4d23581cc9919bf2479f31a37fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize string at separator symbol.  <a href="namespaceLocARNA.html#a267f4d23581cc9919bf2479f31a37fd8">More...</a><br /></td></tr>
<tr class="separator:a267f4d23581cc9919bf2479f31a37fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00570e3805d20f07dace68fa795bf316"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a00570e3805d20f07dace68fa795bf316">split_at_separator</a> (const std::string &amp;s, char sep)</td></tr>
<tr class="memdesc:a00570e3805d20f07dace68fa795bf316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokenize string at separator symbol.  <a href="namespaceLocARNA.html#a00570e3805d20f07dace68fa795bf316">More...</a><br /></td></tr>
<tr class="separator:a00570e3805d20f07dace68fa795bf316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263f9259594a1b6c10a8e62617e2a91f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a263f9259594a1b6c10a8e62617e2a91f">concat_with_separator</a> (const std::vector&lt; std::string &gt; &amp;v, char sep)</td></tr>
<tr class="memdesc:a263f9259594a1b6c10a8e62617e2a91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate strings, inserting separators.  <a href="namespaceLocARNA.html#a263f9259594a1b6c10a8e62617e2a91f">More...</a><br /></td></tr>
<tr class="separator:a263f9259594a1b6c10a8e62617e2a91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eea6d94f689111c4eec5b3a184c058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a19eea6d94f689111c4eec5b3a184c058">get_nonempty_line</a> (std::istream &amp;in, std::string &amp;line)</td></tr>
<tr class="memdesc:a19eea6d94f689111c4eec5b3a184c058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next non-empty/non-comment line.  <a href="namespaceLocARNA.html#a19eea6d94f689111c4eec5b3a184c058">More...</a><br /></td></tr>
<tr class="separator:a19eea6d94f689111c4eec5b3a184c058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdaf308236e33083304cdfba30aa880"><td class="memItemLeft" align="right" valign="top"><a id="a2fdaf308236e33083304cdfba30aa880"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sequence_identity</b> (const <a class="el" href="classLocARNA_1_1string1.html">string1</a> &amp;seqA, const <a class="el" href="classLocARNA_1_1string1.html">string1</a> &amp;seqB)</td></tr>
<tr class="separator:a2fdaf308236e33083304cdfba30aa880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7596627b0047c74dd001ad4d88e1111b"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a7596627b0047c74dd001ad4d88e1111b">prob_exp_f</a> (int seqlen)</td></tr>
<tr class="memdesc:a7596627b0047c74dd001ad4d88e1111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">expected probability of a base pair (null-model)  <a href="namespaceLocARNA.html#a7596627b0047c74dd001ad4d88e1111b">More...</a><br /></td></tr>
<tr class="separator:a7596627b0047c74dd001ad4d88e1111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5961aaef0d385dc289f57853502a51"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#add5961aaef0d385dc289f57853502a51">frag_len_geq</a> (size_t i, size_t j, size_t minlen)</td></tr>
<tr class="separator:add5961aaef0d385dc289f57853502a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9b2f6d07c363d6808cf464b4ca643d"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a8c9b2f6d07c363d6808cf464b4ca643d">frag_len</a> (size_t i, size_t j)</td></tr>
<tr class="separator:a8c9b2f6d07c363d6808cf464b4ca643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de50ef109eb40be5ad2a7ff420b7ee"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a57de50ef109eb40be5ad2a7ff420b7ee">bp_span</a> (size_t i, size_t j)</td></tr>
<tr class="separator:a57de50ef109eb40be5ad2a7ff420b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940020c544ee420726ab6a6614556c67"><td class="memTemplParams" colspan="2">template&lt;class Iterable , typename KeyFun &gt; </td></tr>
<tr class="memitem:a940020c544ee420726ab6a6614556c67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a940020c544ee420726ab6a6614556c67">maximum</a> (const Iterable &amp;x, const KeyFun &amp;key)</td></tr>
<tr class="memdesc:a940020c544ee420726ab6a6614556c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic maximum value of iterable  <a href="namespaceLocARNA.html#a940020c544ee420726ab6a6614556c67">More...</a><br /></td></tr>
<tr class="separator:a940020c544ee420726ab6a6614556c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ddfddf6dec6885981877330fec46ff"><td class="memTemplParams" colspan="2">template&lt;class Iterable , typename KeyFun &gt; </td></tr>
<tr class="memitem:a65ddfddf6dec6885981877330fec46ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a65ddfddf6dec6885981877330fec46ff">minimum</a> (const Iterable &amp;x, const KeyFun &amp;key)</td></tr>
<tr class="memdesc:a65ddfddf6dec6885981877330fec46ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic minimum value of iterable  <a href="namespaceLocARNA.html#a65ddfddf6dec6885981877330fec46ff">More...</a><br /></td></tr>
<tr class="separator:a65ddfddf6dec6885981877330fec46ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7da6c3147864d8ebdfb7c701bf0084"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a0b7da6c3147864d8ebdfb7c701bf0084">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1BasePairs.html#aea68c47e0f454c9777168854230d8dd3">BasePairs::Arc</a> &amp;arc)</td></tr>
<tr class="separator:a0b7da6c3147864d8ebdfb7c701bf0084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0950b050e43bcb8e8bf97f9e1fee32d5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a0950b050e43bcb8e8bf97f9e1fee32d5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1PatternPairMap.html#ac35aacb26084ef20b173d0d6ffc24f84">PatternPairMap::patListTYPE</a> &amp;pat_pair_map)</td></tr>
<tr class="memdesc:a0950b050e43bcb8e8bf97f9e1fee32d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write pattern list of the PatternPairMap to stream  <a href="namespaceLocARNA.html#a0950b050e43bcb8e8bf97f9e1fee32d5">More...</a><br /></td></tr>
<tr class="separator:a0950b050e43bcb8e8bf97f9e1fee32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a627a5a72d549a568315718b23e62e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ac4a627a5a72d549a568315718b23e62e">operator&lt;</a> (const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;epm1, const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;epm2)</td></tr>
<tr class="separator:ac4a627a5a72d549a568315718b23e62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537f2c9aa95a1bf7d670dcf42491eade"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a537f2c9aa95a1bf7d670dcf42491eade">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;epm)</td></tr>
<tr class="separator:a537f2c9aa95a1bf7d670dcf42491eade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10faca67d6690692d0fd40daad8a34"><td class="memTemplParams" colspan="2">template&lt;class T1 &gt; </td></tr>
<tr class="memitem:aef10faca67d6690692d0fd40daad8a34"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aef10faca67d6690692d0fd40daad8a34">max3</a> (const T1 &amp;first, const T1 &amp;second, const T1 &amp;third)</td></tr>
<tr class="separator:aef10faca67d6690692d0fd40daad8a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6c73ac6330da22eb7ea5a0dafd295c"><td class="memTemplParams" colspan="2">template&lt;class T1 &gt; </td></tr>
<tr class="memitem:aac6c73ac6330da22eb7ea5a0dafd295c"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aac6c73ac6330da22eb7ea5a0dafd295c">max4</a> (const T1 &amp;first, const T1 &amp;second, const T1 &amp;third, const T1 &amp;fourth)</td></tr>
<tr class="separator:aac6c73ac6330da22eb7ea5a0dafd295c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52ad1f458d8edeae1ccda8221fc04c3"><td class="memItemLeft" align="right" valign="top"><a id="aa52ad1f458d8edeae1ccda8221fc04c3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aa52ad1f458d8edeae1ccda8221fc04c3">sqdiff</a> (double x, double y)</td></tr>
<tr class="memdesc:aa52ad1f458d8edeae1ccda8221fc04c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">square difference <br /></td></tr>
<tr class="separator:aa52ad1f458d8edeae1ccda8221fc04c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8b028cef2fa210ec43bfae17cfd6cc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a3c8b028cef2fa210ec43bfae17cfd6cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x)</td></tr>
<tr class="separator:a3c8b028cef2fa210ec43bfae17cfd6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f031086761123d2ea246e7e2e0ee41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a74f031086761123d2ea246e7e2e0ee41">operator+</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:a74f031086761123d2ea246e7e2e0ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb15dc15bd57d5ce26753a8489c3ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#afcb15dc15bd57d5ce26753a8489c3ce7">operator-</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:afcb15dc15bd57d5ce26753a8489c3ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79b2cf1929b2725f811e9ff8580aacb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ab79b2cf1929b2725f811e9ff8580aacb">operator+</a> (const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;y)</td></tr>
<tr class="separator:ab79b2cf1929b2725f811e9ff8580aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc742ea413187afcc3a6ab789d3d31bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#adc742ea413187afcc3a6ab789d3d31bd">operator-</a> (const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;y)</td></tr>
<tr class="separator:adc742ea413187afcc3a6ab789d3d31bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c408c938d89fb01332fac0dac30ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a15c408c938d89fb01332fac0dac30ed6">operator+</a> (const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:a15c408c938d89fb01332fac0dac30ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d3c209b7939ec0405a18d6b79081f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a188d3c209b7939ec0405a18d6b79081f">operator-</a> (const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:a188d3c209b7939ec0405a18d6b79081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384c776bdb1788793603a15c06eb1be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a2384c776bdb1788793603a15c06eb1be">operator+</a> (const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:a2384c776bdb1788793603a15c06eb1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44856c4564d2b673467f2346e2c1d42f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a44856c4564d2b673467f2346e2c1d42f">operator-</a> (const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;y)</td></tr>
<tr class="separator:a44856c4564d2b673467f2346e2c1d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1046ff1aab7966b81b50ed0830ccbefe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a1046ff1aab7966b81b50ed0830ccbefe">operator==</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a1046ff1aab7966b81b50ed0830ccbefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1ee2503a78ec1405bc93bbeee486f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a4a1ee2503a78ec1405bc93bbeee486f2">min</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a4a1ee2503a78ec1405bc93bbeee486f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f03a8e178689e70e95b32a3296081e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a8f03a8e178689e70e95b32a3296081e4">max</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a8f03a8e178689e70e95b32a3296081e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adaad509bf973043d9ead1b6fd7eb49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a7adaad509bf973043d9ead1b6fd7eb49">operator&gt;</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a7adaad509bf973043d9ead1b6fd7eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79933b85b46a091c3bc95aab0fa3be0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a79933b85b46a091c3bc95aab0fa3be0d">operator&lt;</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a79933b85b46a091c3bc95aab0fa3be0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ee1fd39951308d5140251170abdd14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a09ee1fd39951308d5140251170abdd14">operator&gt;=</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:a09ee1fd39951308d5140251170abdd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcf248ad3c0aede76392febec550ded"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aafcf248ad3c0aede76392febec550ded">operator&lt;=</a> (const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;x, const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;y)</td></tr>
<tr class="separator:aafcf248ad3c0aede76392febec550ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89049dd7c1d842bb934f1e84d2147c15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a89049dd7c1d842bb934f1e84d2147c15"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a89049dd7c1d842bb934f1e84d2147c15">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; T &gt; mat)</td></tr>
<tr class="separator:a89049dd7c1d842bb934f1e84d2147c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cca95a1e3cd96636e1d719a3967be4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a69cca95a1e3cd96636e1d719a3967be4"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a69cca95a1e3cd96636e1d719a3967be4">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;mat)</td></tr>
<tr class="separator:a69cca95a1e3cd96636e1d719a3967be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b85bfaee945f860955debe253614bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ae2b85bfaee945f860955debe253614bc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1MultipleAlignment.html">MultipleAlignment</a> &amp;ma)</td></tr>
<tr class="memdesc:ae2b85bfaee945f860955debe253614bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple alignment to stream.  <a href="namespaceLocARNA.html#ae2b85bfaee945f860955debe253614bc">More...</a><br /></td></tr>
<tr class="separator:ae2b85bfaee945f860955debe253614bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f37dbeef9d518fabc8bff8769868bb"><td class="memTemplParams" colspan="2"><a id="a24f37dbeef9d518fabc8bff8769868bb"></a>
template&lt;typename T , typename... Args, std::enable_if_t&lt;!has_type&lt; T, std::tuple&lt; Args... &gt;&gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24f37dbeef9d518fabc8bff8769868bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_def</b> (const std::tuple&lt; Args... &gt; &amp;t, const T &amp;def) noexcept</td></tr>
<tr class="separator:a24f37dbeef9d518fabc8bff8769868bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58853e17d287d4dfbe65a5ae12774ae"><td class="memTemplParams" colspan="2"><a id="aa58853e17d287d4dfbe65a5ae12774ae"></a>
template&lt;typename T , typename... Args, std::enable_if_t&lt; has_type&lt; T, std::tuple&lt; Args... &gt;&gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa58853e17d287d4dfbe65a5ae12774ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_def</b> (const std::tuple&lt; Args... &gt; &amp;t, const T &amp;def) noexcept</td></tr>
<tr class="separator:aa58853e17d287d4dfbe65a5ae12774ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae8cc51bb7ebc7c194dd833375f5a3f"><td class="memTemplParams" colspan="2"><a id="a8ae8cc51bb7ebc7c194dd833375f5a3f"></a>
template&lt;typename name , typename ArgTuple &gt; </td></tr>
<tr class="memitem:a8ae8cc51bb7ebc7c194dd833375f5a3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a8ae8cc51bb7ebc7c194dd833375f5a3f">get_named_arg</a> (const ArgTuple &amp;args)</td></tr>
<tr class="memdesc:a8ae8cc51bb7ebc7c194dd833375f5a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a mandatory named argument from argument pack; ensure that argument is given <br /></td></tr>
<tr class="separator:a8ae8cc51bb7ebc7c194dd833375f5a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b728b822e79c11634a93651a9ba68"><td class="memTemplParams" colspan="2">template&lt;typename name , typename ArgsTuple &gt; </td></tr>
<tr class="memitem:aac2b728b822e79c11634a93651a9ba68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aac2b728b822e79c11634a93651a9ba68">get_named_arg_opt</a> (const ArgsTuple &amp;args)</td></tr>
<tr class="separator:aac2b728b822e79c11634a93651a9ba68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3022726c57d65e9cd9395dfd270d889"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ae3022726c57d65e9cd9395dfd270d889">decode_argument</a> (void *argument, int arg_type, const std::string &amp;optarg)</td></tr>
<tr class="memdesc:ae3022726c57d65e9cd9395dfd270d889"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode a string according to arg_type, for internal use  <a href="namespaceLocARNA.html#ae3022726c57d65e9cd9395dfd270d889">More...</a><br /></td></tr>
<tr class="separator:ae3022726c57d65e9cd9395dfd270d889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8cba74391c7db3dfeb7e8ac3db1aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a45f8cba74391c7db3dfeb7e8ac3db1aa">count_opts</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options)</td></tr>
<tr class="separator:a45f8cba74391c7db3dfeb7e8ac3db1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e158ed6ca0ca1aa5125b05b6e67f099"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a1e158ed6ca0ca1aa5125b05b6e67f099">sprint_option_name</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options, int i)</td></tr>
<tr class="separator:a1e158ed6ca0ca1aa5125b05b6e67f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41bb6aa40cde0ea1ec5249b8033a9c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ac41bb6aa40cde0ea1ec5249b8033a9c5">sprint_option_xml</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options, int i)</td></tr>
<tr class="separator:ac41bb6aa40cde0ea1ec5249b8033a9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc954793f70b01d8d8c17a372d6f26a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a7cc954793f70b01d8d8c17a372d6f26a">sprint_option_name_opt</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options, int i)</td></tr>
<tr class="separator:a7cc954793f70b01d8d8c17a372d6f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec61262287fa3681840c782df8d658d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a5ec61262287fa3681840c782df8d658d">process_options</a> (int argc, char *argv[], <a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options)</td></tr>
<tr class="memdesc:a5ec61262287fa3681840c782df8d658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">process options  <a href="namespaceLocARNA.html#a5ec61262287fa3681840c782df8d658d">More...</a><br /></td></tr>
<tr class="separator:a5ec61262287fa3681840c782df8d658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d4ac81921253c808e10d40ebfee09e"><td class="memItemLeft" align="right" valign="top"><a id="a67d4ac81921253c808e10d40ebfee09e"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>convert_arg_type</b> (int arg_type)</td></tr>
<tr class="separator:a67d4ac81921253c808e10d40ebfee09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2a2aabddc24c27303a7a51604f2b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a6b2a2aabddc24c27303a7a51604f2b73">print_options</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> options[])</td></tr>
<tr class="separator:a6b2a2aabddc24c27303a7a51604f2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76051a6480062002cff56f7f353ce3b"><td class="memItemLeft" align="right" valign="top"><a id="ae76051a6480062002cff56f7f353ce3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ae76051a6480062002cff56f7f353ce3b">mandatory</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options, int i)</td></tr>
<tr class="memdesc:ae76051a6480062002cff56f7f353ce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether option is mandatory <br /></td></tr>
<tr class="separator:ae76051a6480062002cff56f7f353ce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856e1a6ee78cf4034487f054914d712b"><td class="memItemLeft" align="right" valign="top"><a id="a856e1a6ee78cf4034487f054914d712b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a856e1a6ee78cf4034487f054914d712b">positional</a> (<a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *options, int i)</td></tr>
<tr class="memdesc:a856e1a6ee78cf4034487f054914d712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether option is positional <br /></td></tr>
<tr class="separator:a856e1a6ee78cf4034487f054914d712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445bc2676b31b9e2cd5568c5dc41bd74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a445bc2676b31b9e2cd5568c5dc41bd74">print_usage</a> (char *progname, <a class="el" href="structLocARNA_1_1option__def.html">option_def</a> options[], bool terse)</td></tr>
<tr class="separator:a445bc2676b31b9e2cd5568c5dc41bd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59013445a3416038f40ba72c172c2a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a59013445a3416038f40ba72c172c2a57">print_galaxy_xml</a> (char *progname, <a class="el" href="structLocARNA_1_1option__def.html">option_def</a> options[])</td></tr>
<tr class="memdesc:a59013445a3416038f40ba72c172c2a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints a galaxy wrapper in xml format  <a href="namespaceLocARNA.html#a59013445a3416038f40ba72c172c2a57">More...</a><br /></td></tr>
<tr class="separator:a59013445a3416038f40ba72c172c2a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1376a31db00c8a5cf987ab02b5c5984a"><td class="memItemLeft" align="right" valign="top"><a id="a1376a31db00c8a5cf987ab02b5c5984a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_wrapped</b> (std::string s, size_t next_offset, size_t offset, size_t width)</td></tr>
<tr class="separator:a1376a31db00c8a5cf987ab02b5c5984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200c90703dcee781c6c5bf245da8d53b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a200c90703dcee781c6c5bf245da8d53b">print_help</a> (char *progname, <a class="el" href="structLocARNA_1_1option__def.html">option_def</a> options[])</td></tr>
<tr class="separator:a200c90703dcee781c6c5bf245da8d53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f97402060d703ba29b73aabdff20e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a94f97402060d703ba29b73aabdff20e0">process_options</a> (int argc, char *argv[], <a class="el" href="structLocARNA_1_1option__def.html">option_def</a> options[])</td></tr>
<tr class="separator:a94f97402060d703ba29b73aabdff20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa24fced0566fda06c280c9a4476d65"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a0aa24fced0566fda06c280c9a4476d65">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1Ribosum.html">Ribosum</a> &amp;ribosum)</td></tr>
<tr class="separator:a0aa24fced0566fda06c280c9a4476d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59fb7b45a69f64705197c4ea43b1b64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#af59fb7b45a69f64705197c4ea43b1b64">is_blank</a> (std::string &amp;s)</td></tr>
<tr class="separator:af59fb7b45a69f64705197c4ea43b1b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540507aaa1984b106eeb85685f7a6077"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a540507aaa1984b106eeb85685f7a6077">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1RibosumFreq.html">RibosumFreq</a> &amp;ribosum)</td></tr>
<tr class="separator:a540507aaa1984b106eeb85685f7a6077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd938d6ba0f952b8acad2318d3e1bc94"><td class="memItemLeft" align="right" valign="top"><a id="acd938d6ba0f952b8acad2318d3e1bc94"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>read_pp_in_loop_block</b> (const std::string &amp;firstline, std::istream &amp;in)</td></tr>
<tr class="separator:acd938d6ba0f952b8acad2318d3e1bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb880aac9263bb594e56d7578c8a60c6"><td class="memItemLeft" align="right" valign="top"><a id="aeb880aac9263bb594e56d7578c8a60c6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aeb880aac9263bb594e56d7578c8a60c6">format_prob</a> (double prob)</td></tr>
<tr class="memdesc:aeb880aac9263bb594e56d7578c8a60c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">output format for probabilities in pp files use limited precision; use scientific notation if it is shorter <br /></td></tr>
<tr class="separator:aeb880aac9263bb594e56d7578c8a60c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313032d105271f217abbe53423d45892"><td class="memItemLeft" align="right" valign="top"><a id="a313032d105271f217abbe53423d45892"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1RnaStructure.html">RnaStructure</a> &amp;structure)</td></tr>
<tr class="separator:a313032d105271f217abbe53423d45892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4efede16c95401c380943c9746a690"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd4efede16c95401c380943c9746a690"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#abd4efede16c95401c380943c9746a690">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:abd4efede16c95401c380943c9746a690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="namespaceLocARNA.html#abd4efede16c95401c380943c9746a690">More...</a><br /></td></tr>
<tr class="separator:abd4efede16c95401c380943c9746a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34c45cd83e3b7329e07229482f1dded"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa34c45cd83e3b7329e07229482f1dded"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aa34c45cd83e3b7329e07229482f1dded">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1SparseVector.html">SparseVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa34c45cd83e3b7329e07229482f1dded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator.  <a href="namespaceLocARNA.html#aa34c45cd83e3b7329e07229482f1dded">More...</a><br /></td></tr>
<tr class="separator:aa34c45cd83e3b7329e07229482f1dded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6a64d1a5cfbd6f05e3c47a6c4ad2ff"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#aaf6a64d1a5cfbd6f05e3c47a6c4ad2ff">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; <a class="el" href="classLocARNA_1_1SparsificationMapper.html#ae678178de195ac727c37e6fd77c2bc25">SparsificationMapper::InfoForPosVec</a> &gt; &amp;pos_vecs_)</td></tr>
<tr class="separator:aaf6a64d1a5cfbd6f05e3c47a6c4ad2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca284fd6d4845b01297fce26422e656"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a4ca284fd6d4845b01297fce26422e656">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classLocARNA_1_1SparsificationMapper.html#ae678178de195ac727c37e6fd77c2bc25">SparsificationMapper::InfoForPosVec</a> &amp;pos_vec_)</td></tr>
<tr class="separator:a4ca284fd6d4845b01297fce26422e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf3684cc4ccf6f6d5681e9f61408c40"><td class="memTemplParams" colspan="2"><a id="afcf3684cc4ccf6f6d5681e9f61408c40"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afcf3684cc4ccf6f6d5681e9f61408c40"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;pair)</td></tr>
<tr class="separator:afcf3684cc4ccf6f6d5681e9f61408c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8337b7206dfcf947f863e118b0bc6a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada8337b7206dfcf947f863e118b0bc6a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ada8337b7206dfcf947f863e118b0bc6a">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:ada8337b7206dfcf947f863e118b0bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960eecf667f01564e2432c1b12bdc7d4"><td class="memTemplParams" colspan="2"><a id="a960eecf667f01564e2432c1b12bdc7d4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a960eecf667f01564e2432c1b12bdc7d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enumerate</b> (T &amp;c)</td></tr>
<tr class="separator:a960eecf667f01564e2432c1b12bdc7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f48f07653edf4f77ce5ddbcc381dac"><td class="memTemplParams" colspan="2"><a id="ab7f48f07653edf4f77ce5ddbcc381dac"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ab7f48f07653edf4f77ce5ddbcc381dac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zip</b> (T1 &amp;c1, T2 &amp;c2)</td></tr>
<tr class="separator:ab7f48f07653edf4f77ce5ddbcc381dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ada7b02e922bc80863c0d2432e8a3e1a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ada7b02e922bc80863c0d2432e8a3e1a1">trace_debugging_output</a></td></tr>
<tr class="memdesc:ada7b02e922bc80863c0d2432e8a3e1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">a static switch to enable generating debugging logs  <a href="namespaceLocARNA.html#ada7b02e922bc80863c0d2432e8a3e1a1">More...</a><br /></td></tr>
<tr class="separator:ada7b02e922bc80863c0d2432e8a3e1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444576387167a3bca6713a2972353956"><td class="memItemLeft" align="right" valign="top"><a id="a444576387167a3bca6713a2972353956"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>the_gap_symbols</b> = &quot;-_~.&quot;</td></tr>
<tr class="separator:a444576387167a3bca6713a2972353956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48e679d54c0e92860e71adc453f0230"><td class="memItemLeft" align="right" valign="top"><a id="ad48e679d54c0e92860e71adc453f0230"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>simplified_gap_symbols</b> = &quot;---.&quot;</td></tr>
<tr class="separator:ad48e679d54c0e92860e71adc453f0230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a260ba354053613000f0490d5f46a4"><td class="memItemLeft" align="right" valign="top"><a id="ad7a260ba354053613000f0490d5f46a4"></a>
<a class="el" href="classLocARNA_1_1StopWatch.html">StopWatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#ad7a260ba354053613000f0490d5f46a4">stopwatch</a></td></tr>
<tr class="memdesc:ad7a260ba354053613000f0490d5f46a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">global StopWatch object <br /></td></tr>
<tr class="separator:ad7a260ba354053613000f0490d5f46a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef8566e58bc92aeea440e27ee14aa86"><td class="memItemLeft" align="right" valign="top"><a id="a8ef8566e58bc92aeea440e27ee14aa86"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a8ef8566e58bc92aeea440e27ee14aa86">O_error_msg</a></td></tr>
<tr class="memdesc:a8ef8566e58bc92aeea440e27ee14aa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">string holding for error message <br /></td></tr>
<tr class="separator:a8ef8566e58bc92aeea440e27ee14aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4445c200ae4811b22117fc3f6586762b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#a4445c200ae4811b22117fc3f6586762b">punA_tab</a></td></tr>
<tr class="separator:a4445c200ae4811b22117fc3f6586762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe22d7c55ff8f95ceb388a4a82c0ada5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLocARNA.html#abe22d7c55ff8f95ceb388a4a82c0ada5">punB_tab</a></td></tr>
<tr class="separator:abe22d7c55ff8f95ceb388a4a82c0ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mechanism to name arguments via unique argument classes; in the function, the actual arguments can be retrieved from an argument pack by their type.</p>
<p>Requires functions with named arguments to use (variadic) templates </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aec19a1f8c8ca6a6070c38a898d2b8db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19a1f8c8ca6a6070c38a898d2b8db4">&#9670;&nbsp;</a></span>FLT_OR_DBL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceLocARNA.html#aec19a1f8c8ca6a6070c38a898d2b8db4">LocARNA::FLT_OR_DBL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>select FLT_OR_DBL </p>
<dl class="section note"><dt>Note</dt><dd>By defining as double, we rely on Vienna package compiled with LARGE_PF (defined in fold_vars.h) </dd>
<dd>
By defining this here, we get rid of dependency of header file ViennaRNA/fold_vars.h in pre-2.2.x version of the Vienna package. In 2.2.x, we simply redeclare the typedef. </dd></dl>

</div>
</div>
<a id="ae111d1cda0f077827bd2e90d6b14cff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae111d1cda0f077827bd2e90d6b14cff3">&#9670;&nbsp;</a></span>infty_score_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> <a class="el" href="namespaceLocARNA.html#ae111d1cda0f077827bd2e90d6b14cff3">LocARNA::infty_score_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>an extended score_t that can store and calculate with infinite values (i.p. we use -infty for invalid matrix entries) </p>

</div>
</div>
<a id="a77faf6648dd8631aac85fadfc1deffae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77faf6648dd8631aac85fadfc1deffae">&#9670;&nbsp;</a></span>ProbMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; double &gt; <a class="el" href="namespaceLocARNA.html#a77faf6648dd8631aac85fadfc1deffae">LocARNA::ProbMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix for storing probabilities </p>
<p>Matrix of probabilities. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a57de50ef109eb40be5ad2a7ff420b7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de50ef109eb40be5ad2a7ff420b7ee">&#9670;&nbsp;</a></span>bp_span()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t LocARNA::bp_span </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Span of a base pair</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>left end </td></tr>
    <tr><td class="paramname">j</td><td>right end</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>span of base pair (i,j), i.e. the number of bases in the range i..j </dd></dl>

</div>
</div>
<a id="a263f9259594a1b6c10a8e62617e2a91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263f9259594a1b6c10a8e62617e2a91f">&#9670;&nbsp;</a></span>concat_with_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LocARNA::concat_with_separator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate strings, inserting separators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector of strings </td></tr>
    <tr><td class="paramname">sep</td><td>separator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of concatenated strings </dd></dl>

</div>
</div>
<a id="a45f8cba74391c7db3dfeb7e8ac3db1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f8cba74391c7db3dfeb7e8ac3db1aa">&#9670;&nbsp;</a></span>count_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LocARNA::count_opts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts the options in (null-terminated) array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>array of options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>process_options()</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>number of options in array </dd></dl>

</div>
</div>
<a id="ae3022726c57d65e9cd9395dfd270d889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3022726c57d65e9cd9395dfd270d889">&#9670;&nbsp;</a></span>decode_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::decode_argument </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>optarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decode a string according to arg_type, for internal use </p>
<p>decode an argument according to specified type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argument</td><td></td></tr>
    <tr><td class="paramname">arg_type</td><td></td></tr>
    <tr><td class="paramname">optarg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success</dd></dl>
<p>decode the string optarg according to the type of argument arg_type and write the result to argument</p>
<dl class="section return"><dt>Returns</dt><dd>whether argument could be decoded </dd></dl>

</div>
</div>
<a id="a8c9b2f6d07c363d6808cf464b4ca643d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9b2f6d07c363d6808cf464b4ca643d">&#9670;&nbsp;</a></span>frag_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t LocARNA::frag_len </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of bases in a fragment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>left end of fragment </td></tr>
    <tr><td class="paramname">j</td><td>right end of fragment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bases in range i..j </dd></dl>

</div>
</div>
<a id="add5961aaef0d385dc289f57853502a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5961aaef0d385dc289f57853502a51">&#9670;&nbsp;</a></span>frag_len_geq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool LocARNA::frag_len_geq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for sufficient fragment length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>left end of fragment </td></tr>
    <tr><td class="paramname">j</td><td>right end of fragment </td></tr>
    <tr><td class="paramname">minlen</td><td>minimum length of fragment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether fragment has at least length minlen </dd></dl>

</div>
</div>
<a id="aac2b728b822e79c11634a93651a9ba68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b728b822e79c11634a93651a9ba68">&#9670;&nbsp;</a></span>get_named_arg_opt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename name , typename ArgsTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LocARNA::get_named_arg_opt </td>
          <td>(</td>
          <td class="paramtype">const ArgsTuple &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get an optional named argument from argument pack; return default value (empty constructor of named parameter class) if argument does not exist </p>

</div>
</div>
<a id="a19eea6d94f689111c4eec5b3a184c058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19eea6d94f689111c4eec5b3a184c058">&#9670;&nbsp;</a></span>get_nonempty_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::get_nonempty_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next non-empty/non-comment line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">line</td><td>line</td></tr>
  </table>
  </dd>
</dl>
<p>Get the next line of stream in that is neither emtpy nor starts with white space (the latter is considered a comment in pp and (our variant of) clustalw files).</p>
<p>While newline is quoted concatenate lines. (note: this is kept simple, such that we cannot quote quotes)</p>
<dl class="section note"><dt>Note</dt><dd>on failure, sets line to empty</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a0fd81b1324e262d2f5a9609036af4889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd81b1324e262d2f5a9609036af4889">&#9670;&nbsp;</a></span>has_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::has_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test string prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string </td></tr>
    <tr><td class="paramname">p</td><td>prefix </td></tr>
    <tr><td class="paramname">start</td><td>optional start position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether s has prefix p (after dropping the first start characters from s) </dd></dl>

</div>
</div>
<a id="af59fb7b45a69f64705197c4ea43b1b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59fb7b45a69f64705197c4ea43b1b64">&#9670;&nbsp;</a></span>is_blank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::is_blank </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for only blank characters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be tested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether s consists of only blank characters </dd></dl>

</div>
</div>
<a id="aa694cc6938cf6d2df2b3b1bd04a5026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa694cc6938cf6d2df2b3b1bd04a5026a">&#9670;&nbsp;</a></span>is_gap_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::is_gap_symbol </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for gap symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>character to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether c codes for a gap according to global constant gap_symbols </dd></dl>

</div>
</div>
<a id="a8f03a8e178689e70e95b32a3296081e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f03a8e178689e70e95b32a3296081e4">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max of x and y </dd></dl>

</div>
</div>
<a id="aef10faca67d6690692d0fd40daad8a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef10faca67d6690692d0fd40daad8a34">&#9670;&nbsp;</a></span>max3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 LocARNA::max3 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>third</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes the maximum of three values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first value </td></tr>
    <tr><td class="paramname">second</td><td>second value </td></tr>
    <tr><td class="paramname">third</td><td>third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum of the three input values </dd></dl>

</div>
</div>
<a id="aac6c73ac6330da22eb7ea5a0dafd295c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6c73ac6330da22eb7ea5a0dafd295c">&#9670;&nbsp;</a></span>max4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 LocARNA::max4 </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>third</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>fourth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>computes the maximum of four values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>first value </td></tr>
    <tr><td class="paramname">second</td><td>second value </td></tr>
    <tr><td class="paramname">third</td><td>third value </td></tr>
    <tr><td class="paramname">fourth</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum of the four input values </dd></dl>

</div>
</div>
<a id="a940020c544ee420726ab6a6614556c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940020c544ee420726ab6a6614556c67">&#9670;&nbsp;</a></span>maximum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterable , typename KeyFun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LocARNA::maximum </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyFun &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic maximum value of iterable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>iterable object (e.g. container) </td></tr>
    <tr><td class="paramname">key</td><td>key function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max{ key(y) | y in x } </dd></dl>

</div>
</div>
<a id="a4a1ee2503a78ec1405bc93bbeee486f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1ee2503a78ec1405bc93bbeee486f2">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min of x and y </dd></dl>

</div>
</div>
<a id="a65ddfddf6dec6885981877330fec46ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ddfddf6dec6885981877330fec46ff">&#9670;&nbsp;</a></span>minimum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterable , typename KeyFun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LocARNA::minimum </td>
          <td>(</td>
          <td class="paramtype">const Iterable &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyFun &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic minimum value of iterable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>iterable object (e.g. container) </td></tr>
    <tr><td class="paramname">key</td><td>key function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min{ key(y) | y in x } </dd></dl>

</div>
</div>
<a id="a1ec4b9da4789fd38379743edb18be34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec4b9da4789fd38379743edb18be34e">&#9670;&nbsp;</a></span>normalize_rna_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::normalize_rna_sequence </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform an RNA sequence string. </p>
<p>Transform, such that all characters are upper case and Ts are translated to Us</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2384c776bdb1788793603a15c06eb1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384c776bdb1788793603a15c06eb1be">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> LocARNA::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x plus y </dd></dl>

</div>
</div>
<a id="a15c408c938d89fb01332fac0dac30ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c408c938d89fb01332fac0dac30ed6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> LocARNA::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x plus y </dd></dl>

</div>
</div>
<a id="ab79b2cf1929b2725f811e9ff8580aacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79b2cf1929b2725f811e9ff8580aacb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x plus y </dd></dl>

</div>
</div>
<a id="a74f031086761123d2ea246e7e2e0ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f031086761123d2ea246e7e2e0ee41">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x plus y </dd></dl>

</div>
</div>
<a id="a44856c4564d2b673467f2346e2c1d42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44856c4564d2b673467f2346e2c1d42f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> LocARNA::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x minus y </dd></dl>

</div>
</div>
<a id="a188d3c209b7939ec0405a18d6b79081f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188d3c209b7939ec0405a18d6b79081f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> LocARNA::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x minus y </dd></dl>

</div>
</div>
<a id="adc742ea413187afcc3a6ab789d3d31bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc742ea413187afcc3a6ab789d3d31bd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1InftyInt.html">InftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x minus y </dd></dl>

</div>
</div>
<a id="afcb15dc15bd57d5ce26753a8489c3ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb15dc15bd57d5ce26753a8489c3ce7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> LocARNA::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1FiniteInt.html">FiniteInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x minus y </dd></dl>

</div>
</div>
<a id="ac4a627a5a72d549a568315718b23e62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a627a5a72d549a568315718b23e62e">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;&#160;</td>
          <td class="paramname"><em>epm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;&#160;</td>
          <td class="paramname"><em>epm2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compare EPMs (for sorting according to the tolerance left) @params epm1 input EPM @params epm2 input EPM </p><dl class="section return"><dt>Returns</dt><dd>true, if the maximal tolerance that is left for epm1 is larger than the one for epm2 false, otherwise </dd></dl>

</div>
</div>
<a id="a79933b85b46a091c3bc95aab0fa3be0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79933b85b46a091c3bc95aab0fa3be0d">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Less than operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is less than y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is undefined when comparing infinte values of the same sign. </dd></dl>

</div>
</div>
<a id="a213e1cc9393b5afb4e847ffea0a62de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213e1cc9393b5afb4e847ffea0a62de0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1AlignerRestriction.html">AlignerRestriction</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for objects of AlignerRestrictions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">r</td><td>object of AlignerRestriction to be written to stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Writes r to out </dd></dl>

</div>
</div>
<a id="aed8137ad7797225a5fc078e9264ce3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8137ad7797225a5fc078e9264ce3db">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1Alphabet.html">Alphabet</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator writing alphabet to output stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">a</td><td>the alphabet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing alphabet </dd></dl>

</div>
</div>
<a id="a0b7da6c3147864d8ebdfb7c701bf0084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7da6c3147864d8ebdfb7c701bf0084">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1BasePairs.html#aea68c47e0f454c9777168854230d8dd3">BasePairs::Arc</a> &amp;&#160;</td>
          <td class="paramname"><em>arc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator for writing arc to output stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">arc</td><td>the arc to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing arc </dd></dl>

</div>
</div>
<a id="a537f2c9aa95a1bf7d670dcf42491eade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537f2c9aa95a1bf7d670dcf42491eade">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1EPM.html">EPM</a> &amp;&#160;</td>
          <td class="paramname"><em>epm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>prints the EPM </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream object </td></tr>
    <tr><td class="paramname">epm</td><td>EPM that is printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream object </dd></dl>

</div>
</div>
<a id="ae2b85bfaee945f860955debe253614bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b85bfaee945f860955debe253614bc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1MultipleAlignment.html">MultipleAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple alignment to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">ma</td><td>multiple alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a id="a0950b050e43bcb8e8bf97f9e1fee32d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950b050e43bcb8e8bf97f9e1fee32d5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1PatternPairMap.html#ac35aacb26084ef20b173d0d6ffc24f84">PatternPairMap::patListTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>pat_pair_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write pattern list of the PatternPairMap to stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream object </td></tr>
    <tr><td class="paramname">the</td><td>pattern list of the PatternPairMap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream object </dd></dl>

</div>
</div>
<a id="a0aa24fced0566fda06c280c9a4476d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa24fced0566fda06c280c9a4476d65">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1Ribosum.html">Ribosum</a> &amp;&#160;</td>
          <td class="paramname"><em>ribosum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">ribosum</td><td>Ribosum to be written to stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing </dd></dl>

</div>
</div>
<a id="a540507aaa1984b106eeb85685f7a6077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540507aaa1984b106eeb85685f7a6077">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1RibosumFreq.html">RibosumFreq</a> &amp;&#160;</td>
          <td class="paramname"><em>ribosum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">ribosum</td><td>Ribosum to be written to stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing </dd></dl>

</div>
</div>
<a id="abd4efede16c95401c380943c9746a690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4efede16c95401c380943c9746a690">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">m</td><td>sparse matrix to be writing to stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing </dd></dl>

</div>
</div>
<a id="aa34c45cd83e3b7329e07229482f1dded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34c45cd83e3b7329e07229482f1dded">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1SparseVector.html">SparseVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">m</td><td>sparse vector to be writing to stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing </dd></dl>

</div>
</div>
<a id="a4ca284fd6d4845b01297fce26422e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca284fd6d4845b01297fce26422e656">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1SparsificationMapper.html#ae678178de195ac727c37e6fd77c2bc25">SparsificationMapper::InfoForPosVec</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_vec_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prints all valid sequence positions with additional information for one index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream object </td></tr>
    <tr><td class="paramname">pos_vec_</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream object </dd></dl>

</div>
</div>
<a id="aaf6a64d1a5cfbd6f05e3c47a6c4ad2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6a64d1a5cfbd6f05e3c47a6c4ad2ff">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLocARNA_1_1SparsificationMapper.html#ae678178de195ac727c37e6fd77c2bc25">SparsificationMapper::InfoForPosVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_vecs_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prints all valid sequence positions with additional information for all indices </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream object </td></tr>
    <tr><td class="paramname">pos_vecs_</td><td>input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream object </dd></dl>

</div>
</div>
<a id="ada8337b7206dfcf947f863e118b0bc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8337b7206dfcf947f863e118b0bc6a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prints a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream object </td></tr>
    <tr><td class="paramname">vec</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream object </dd></dl>

</div>
</div>
<a id="a3c8b028cef2fa210ec43bfae17cfd6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8b028cef2fa210ec43bfae17cfd6cc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator for writing object of TaintedInftyInt to output stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">x</td><td>the object to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing x </dd></dl>

</div>
</div>
<a id="a89049dd7c1d842bb934f1e84d2147c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89049dd7c1d842bb934f1e84d2147c15">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LocARNA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator for writing (templated) matrix to output stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream after writing matrix mat </dd></dl>

</div>
</div>
<a id="aafcf248ad3c0aede76392febec550ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcf248ad3c0aede76392febec550ded">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Less or equal than operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is less or equal than y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is undefined when comparing infinte values of the same sign. </dd></dl>

</div>
</div>
<a id="a1046ff1aab7966b81b50ed0830ccbefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1046ff1aab7966b81b50ed0830ccbefe">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 (tainted) </td></tr>
    <tr><td class="paramname">y</td><td>operand 2 (tainted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x equals y </dd></dl>

</div>
</div>
<a id="a7adaad509bf973043d9ead1b6fd7eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adaad509bf973043d9ead1b6fd7eb49">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Greater than operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is greater than y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is undefined when comparing infinte values of the same sign. </dd></dl>

</div>
</div>
<a id="a09ee1fd39951308d5140251170abdd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ee1fd39951308d5140251170abdd14">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLocARNA_1_1TaintedInftyInt.html">TaintedInftyInt</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Greater or equal than operator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>operand 1 </td></tr>
    <tr><td class="paramname">y</td><td>operand 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is greater or equal than y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is undefined when comparing infinte values of the same sign. </dd></dl>

</div>
</div>
<a id="a69cca95a1e3cd96636e1d719a3967be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cca95a1e3cd96636e1d719a3967be4">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; LocARNA::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLocARNA_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input operator for reading (templated) matrix from input stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>the input stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>the matrix to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream after reading matrix mat </dd></dl>

</div>
</div>
<a id="a59013445a3416038f40ba72c172c2a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59013445a3416038f40ba72c172c2a57">&#9670;&nbsp;</a></span>print_galaxy_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::print_galaxy_xml </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>progname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a>&#160;</td>
          <td class="paramname"><em>options</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints a galaxy wrapper in xml format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progname</td><td>Name of program </td></tr>
    <tr><td class="paramname">options</td><td>Options array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a200c90703dcee781c6c5bf245da8d53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200c90703dcee781c6c5bf245da8d53b">&#9670;&nbsp;</a></span>print_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::print_help </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>progname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a>&#160;</td>
          <td class="paramname"><em>options</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prints a standard help string suited for short help output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progname</td><td>Name of program </td></tr>
    <tr><td class="paramname">options</td><td>Options array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2a2aabddc24c27303a7a51604f2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2a2aabddc24c27303a7a51604f2b73">&#9670;&nbsp;</a></span>print_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::print_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a>&#160;</td>
          <td class="paramname"><em>options</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all options and their settings to standard out</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>options array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a445bc2676b31b9e2cd5568c5dc41bd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445bc2676b31b9e2cd5568c5dc41bd74">&#9670;&nbsp;</a></span>print_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::print_usage </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>progname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a>&#160;</td>
          <td class="paramname"><em>options</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>terse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prints a standard usage string suited for short help output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progname</td><td>Name of program </td></tr>
    <tr><td class="paramname">options</td><td>Options array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7596627b0047c74dd001ad4d88e1111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7596627b0047c74dd001ad4d88e1111b">&#9670;&nbsp;</a></span>prob_exp_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double LocARNA::prob_exp_f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seqlen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>expected probability of a base pair (null-model) </p>
<dl class="section note"><dt>Note</dt><dd>magic formula for expected probability (aka background); actually questionable </dd></dl>

</div>
</div>
<a id="a5ec61262287fa3681840c782df8d658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec61262287fa3681840c782df8d658d">&#9670;&nbsp;</a></span>process_options() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::process_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process options </p>
<p>Processes an argument string as given to main() according to an array of options descriptions of type option_def.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>argument counter from main() </td></tr>
    <tr><td class="paramname">argv</td><td>argument vector from main() </td></tr>
    <tr><td class="paramname">options</td><td>array describing the options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if all required options are read FALSE if a required option is missing, or unknown options occured</dd></dl>
<dl class="section note"><dt>Note</dt><dd>last entry in definitions array should contain only 0's (in fact longname==0 and shortname==0 is tested) </dd></dl>

</div>
</div>
<a id="a94f97402060d703ba29b73aabdff20e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f97402060d703ba29b73aabdff20e0">&#9670;&nbsp;</a></span>process_options() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::process_options </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a>&#160;</td>
          <td class="paramname"><em>options</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>process options </p>

</div>
</div>
<a id="a00570e3805d20f07dace68fa795bf316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00570e3805d20f07dace68fa795bf316">&#9670;&nbsp;</a></span>split_at_separator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; LocARNA::split_at_separator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenize string at separator symbol. </p>
<p>Split at seperator symbol and write to output vector of strings. Output vector is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string </td></tr>
    <tr><td class="paramname">sep</td><td>separator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of strings </dd></dl>

</div>
</div>
<a id="a267f4d23581cc9919bf2479f31a37fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f4d23581cc9919bf2479f31a37fd8">&#9670;&nbsp;</a></span>split_at_separator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::split_at_separator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokenize string at separator symbol. </p>
<p>Split at seperator symbol and write to output vector of strings. Output vector is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string </td></tr>
    <tr><td class="paramname">sep</td><td>separator </td></tr>
    <tr><td class="paramname">v[out]</td><td>vector of strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e158ed6ca0ca1aa5125b05b6e67f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e158ed6ca0ca1aa5125b05b6e67f099">&#9670;&nbsp;</a></span>sprint_option_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LocARNA::sprint_option_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write option name to string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>options array </td></tr>
    <tr><td class="paramname">i</td><td>index of option to be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>option string </dd></dl>

</div>
</div>
<a id="a7cc954793f70b01d8d8c17a372d6f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc954793f70b01d8d8c17a372d6f26a">&#9670;&nbsp;</a></span>sprint_option_name_opt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LocARNA::sprint_option_name_opt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print option name to string buffer, marking whether it is optional by []</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>options array </td></tr>
    <tr><td class="paramname">i</td><td>index of option to be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>option string </dd></dl>

</div>
</div>
<a id="ac41bb6aa40cde0ea1ec5249b8033a9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41bb6aa40cde0ea1ec5249b8033a9c5">&#9670;&nbsp;</a></span>sprint_option_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LocARNA::sprint_option_xml </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLocARNA_1_1option__def.html">option_def</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an option as xml in Galaxy Wrapper format to string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>options array </td></tr>
    <tr><td class="paramname">i</td><td>index of option to be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xml option string </dd></dl>

</div>
</div>
<a id="ac064250cb39851185b7fb25eebf1d756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac064250cb39851185b7fb25eebf1d756">&#9670;&nbsp;</a></span>transform_toupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocARNA::transform_toupper </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts char to upper case. </p>
<p>Function class used by transform_toupper().</p>
<p>Convert string to all upper case</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>string is all upper case </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4445c200ae4811b22117fc3f6586762b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4445c200ae4811b22117fc3f6586762b">&#9670;&nbsp;</a></span>punA_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; LocARNA::punA_tab</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vector for unpaired probabilities temporarily required by sigma_ </p><dl class="section note"><dt>Note</dt><dd>initialized in precompute sigma, if needed </dd></dl>

</div>
</div>
<a id="abe22d7c55ff8f95ceb388a4a82c0ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe22d7c55ff8f95ceb388a4a82c0ada5">&#9670;&nbsp;</a></span>punB_tab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; LocARNA::punB_tab</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vector for unpaired probabilities </p><dl class="section see"><dt>See also</dt><dd>punB_tab </dd></dl>

</div>
</div>
<a id="ada7b02e922bc80863c0d2432e8a3e1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7b02e922bc80863c0d2432e8a3e1a1">&#9670;&nbsp;</a></span>trace_debugging_output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LocARNA::trace_debugging_output</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <span class="keyword">false</span></div>
</div><!-- fragment -->
<p>a static switch to enable generating debugging logs </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 19 2022 11:24:47 for LocARNA-2.0.0 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
